{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar updateHash = function updateHash(hash, historyUpdate) {\n  var hashVal = hash.indexOf(\"#\") === 0 ? hash.substring(1) : hash;\n  var hashToUpdate = hashVal ? \"#\" + hashVal : \"\";\n  var curLoc = window && window.location;\n  var urlToPush = hashToUpdate ? curLoc.pathname + curLoc.search + hashToUpdate : curLoc.pathname + curLoc.search;\n  historyUpdate ? history.pushState(history.state, \"\", urlToPush) : history.replaceState(history.state, \"\", urlToPush);\n};\nvar getHash = function getHash() {\n  return window.location.hash.replace(/^#/, \"\");\n};\nvar filterElementInContainer = function filterElementInContainer(container) {\n  return function (element) {\n    return container.contains ? container != element && container.contains(element) : !!(container.compareDocumentPosition(element) & 16);\n  };\n};\nvar isPositioned = function isPositioned(element) {\n  return getComputedStyle(element).position !== \"static\";\n};\nvar getElementOffsetInfoUntil = function getElementOffsetInfoUntil(element, predicate) {\n  var offsetTop = element.offsetTop;\n  var currentOffsetParent = element.offsetParent;\n  while (currentOffsetParent && !predicate(currentOffsetParent)) {\n    offsetTop += currentOffsetParent.offsetTop;\n    currentOffsetParent = currentOffsetParent.offsetParent;\n  }\n  return {\n    offsetTop: offsetTop,\n    offsetParent: currentOffsetParent\n  };\n};\nvar scrollOffset = function scrollOffset(c, t, horizontal) {\n  if (horizontal) {\n    return c === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(c).position !== \"static\" ? t.offsetLeft : t.offsetLeft - c.offsetLeft;\n  } else {\n    if (c === document) {\n      return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);\n    }\n\n    // The offsetParent of an element, according to MDN, is its nearest positioned\n    // (an element whose position is anything other than static) ancestor. The offsetTop\n    // of an element is taken with respect to its offsetParent which may not neccessarily\n    // be its parentElement except the parent itself is positioned.\n\n    // So if containerElement is positioned, then it must be an offsetParent somewhere\n    // If it happens that targetElement is a descendant of the containerElement, and there\n    // is not intermediate positioned element between the two of them, i.e.\n    // targetElement\"s offsetParent is the same as the containerElement, then the\n    // distance between the two will be the offsetTop of the targetElement.\n    // If, on the other hand, there are intermediate positioned elements between the\n    // two entities, the distance between the targetElement and the containerElement\n    // will be the accumulation of the offsetTop of the element and that of its\n    // subsequent offsetParent until the containerElement is reached, since it\n    // will also be an offsetParent at some point due to the fact that it is positioned.\n\n    // If the containerElement is not positioned, then it can\"t be an offsetParent,\n    // which means that the offsetTop of the targetElement would not be with respect to it.\n    // However, if the two of them happen to have the same offsetParent, then\n    // the distance between them will be the difference between their offsetTop\n    // since they are both taken with respect to the same entity.\n    // The last resort would be to accumulate their offsetTop until a common\n    // offsetParent is reached (usually the document) and taking the difference\n    // between the accumulated offsetTops\n\n    if (isPositioned(c)) {\n      if (t.offsetParent !== c) {\n        var isContainerElementOrDocument = function isContainerElementOrDocument(e) {\n          return e === c || e === document;\n        };\n        var _getElementOffsetInfo = getElementOffsetInfoUntil(t, isContainerElementOrDocument),\n          offsetTop = _getElementOffsetInfo.offsetTop,\n          offsetParent = _getElementOffsetInfo.offsetParent;\n        if (offsetParent !== c) {\n          throw new Error(\"Seems containerElement is not an ancestor of the Element\");\n        }\n        return offsetTop;\n      }\n      return t.offsetTop;\n    }\n    if (t.offsetParent === c.offsetParent) {\n      return t.offsetTop - c.offsetTop;\n    }\n    var isDocument = function isDocument(e) {\n      return e === document;\n    };\n    return getElementOffsetInfoUntil(t, isDocument).offsetTop - getElementOffsetInfoUntil(c, isDocument).offsetTop;\n  }\n};\nexports.default = {\n  updateHash: updateHash,\n  getHash: getHash,\n  filterElementInContainer: filterElementInContainer,\n  scrollOffset: scrollOffset\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","updateHash","hash","historyUpdate","hashVal","indexOf","substring","hashToUpdate","curLoc","window","location","urlToPush","pathname","search","history","pushState","state","replaceState","getHash","replace","filterElementInContainer","container","element","contains","compareDocumentPosition","isPositioned","getComputedStyle","position","getElementOffsetInfoUntil","predicate","offsetTop","currentOffsetParent","offsetParent","scrollOffset","c","t","horizontal","document","getBoundingClientRect","left","scrollX","pageXOffset","offsetLeft","top","scrollY","pageYOffset","isContainerElementOrDocument","e","_getElementOffsetInfo","Error","isDocument","default"],"sources":["C:/Users/maria/Documents/MDS/2023-2-CENTAURI/frontend/node_modules/react-scroll/modules/mixins/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar updateHash = function updateHash(hash, historyUpdate) {\n  var hashVal = hash.indexOf(\"#\") === 0 ? hash.substring(1) : hash;\n  var hashToUpdate = hashVal ? \"#\" + hashVal : \"\";\n  var curLoc = window && window.location;\n  var urlToPush = hashToUpdate ? curLoc.pathname + curLoc.search + hashToUpdate : curLoc.pathname + curLoc.search;\n  historyUpdate ? history.pushState(history.state, \"\", urlToPush) : history.replaceState(history.state, \"\", urlToPush);\n};\n\nvar getHash = function getHash() {\n  return window.location.hash.replace(/^#/, \"\");\n};\n\nvar filterElementInContainer = function filterElementInContainer(container) {\n  return function (element) {\n    return container.contains ? container != element && container.contains(element) : !!(container.compareDocumentPosition(element) & 16);\n  };\n};\n\nvar isPositioned = function isPositioned(element) {\n  return getComputedStyle(element).position !== \"static\";\n};\n\nvar getElementOffsetInfoUntil = function getElementOffsetInfoUntil(element, predicate) {\n  var offsetTop = element.offsetTop;\n  var currentOffsetParent = element.offsetParent;\n\n  while (currentOffsetParent && !predicate(currentOffsetParent)) {\n    offsetTop += currentOffsetParent.offsetTop;\n    currentOffsetParent = currentOffsetParent.offsetParent;\n  }\n\n  return { offsetTop: offsetTop, offsetParent: currentOffsetParent };\n};\n\nvar scrollOffset = function scrollOffset(c, t, horizontal) {\n  if (horizontal) {\n    return c === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(c).position !== \"static\" ? t.offsetLeft : t.offsetLeft - c.offsetLeft;\n  } else {\n    if (c === document) {\n      return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);\n    }\n\n    // The offsetParent of an element, according to MDN, is its nearest positioned\n    // (an element whose position is anything other than static) ancestor. The offsetTop\n    // of an element is taken with respect to its offsetParent which may not neccessarily\n    // be its parentElement except the parent itself is positioned.\n\n    // So if containerElement is positioned, then it must be an offsetParent somewhere\n    // If it happens that targetElement is a descendant of the containerElement, and there\n    // is not intermediate positioned element between the two of them, i.e.\n    // targetElement\"s offsetParent is the same as the containerElement, then the\n    // distance between the two will be the offsetTop of the targetElement.\n    // If, on the other hand, there are intermediate positioned elements between the\n    // two entities, the distance between the targetElement and the containerElement\n    // will be the accumulation of the offsetTop of the element and that of its\n    // subsequent offsetParent until the containerElement is reached, since it\n    // will also be an offsetParent at some point due to the fact that it is positioned.\n\n    // If the containerElement is not positioned, then it can\"t be an offsetParent,\n    // which means that the offsetTop of the targetElement would not be with respect to it.\n    // However, if the two of them happen to have the same offsetParent, then\n    // the distance between them will be the difference between their offsetTop\n    // since they are both taken with respect to the same entity.\n    // The last resort would be to accumulate their offsetTop until a common\n    // offsetParent is reached (usually the document) and taking the difference\n    // between the accumulated offsetTops\n\n    if (isPositioned(c)) {\n      if (t.offsetParent !== c) {\n        var isContainerElementOrDocument = function isContainerElementOrDocument(e) {\n          return e === c || e === document;\n        };\n\n        var _getElementOffsetInfo = getElementOffsetInfoUntil(t, isContainerElementOrDocument),\n            offsetTop = _getElementOffsetInfo.offsetTop,\n            offsetParent = _getElementOffsetInfo.offsetParent;\n\n        if (offsetParent !== c) {\n          throw new Error(\"Seems containerElement is not an ancestor of the Element\");\n        }\n\n        return offsetTop;\n      }\n\n      return t.offsetTop;\n    }\n\n    if (t.offsetParent === c.offsetParent) {\n      return t.offsetTop - c.offsetTop;\n    }\n\n    var isDocument = function isDocument(e) {\n      return e === document;\n    };\n    return getElementOffsetInfoUntil(t, isDocument).offsetTop - getElementOffsetInfoUntil(c, isDocument).offsetTop;\n  }\n};\n\nexports.default = {\n  updateHash: updateHash,\n  getHash: getHash,\n  filterElementInContainer: filterElementInContainer,\n  scrollOffset: scrollOffset\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}